/**
 * Type definitions for the Claude Sessions Explorer web app.
 *
 * This file defines all TypeScript interfaces used throughout the application.
 * The data originates from Claude Code's local storage at ~/.claude/
 *
 * Data sources:
 * - Stats: ~/.claude/stats-cache.json
 * - Projects: ~/.claude/projects/{project-id}/
 * - Session Index: ~/.claude/projects/{project-id}/sessions-index.json
 * - Session Messages: ~/.claude/projects/{project-id}/{session-id}.jsonl
 * - Session Commits: ~/.claude/projects/{project-id}/.commits.json
 */

// =============================================================================
// STATS CACHE TYPES
// Source: ~/.claude/stats-cache.json
// Pre-computed statistics about Claude Code usage across all sessions
// =============================================================================

/**
 * Daily activity metrics aggregated across all sessions.
 * Used to display usage trends over time on the dashboard.
 */
export interface DailyActivity {
  /** ISO date string (YYYY-MM-DD) */
  date: string;
  /** Total messages exchanged on this day */
  messageCount: number;
  /** Number of unique sessions active on this day */
  sessionCount: number;
  /** Number of tool calls (Bash, Read, Write, etc.) made */
  toolCallCount: number;
}

/**
 * Token usage broken down by model for a specific day.
 * Tracks which AI models were used and how many tokens each consumed.
 */
export interface DailyModelTokens {
  /** ISO date string (YYYY-MM-DD) */
  date: string;
  /** Map of model name to total tokens used (e.g., "claude-sonnet-4-20250514": 50000) */
  tokensByModel: Record<string, number>;
}

/**
 * Aggregate token usage and cost for a specific model.
 * Tracks both input/output tokens and cache efficiency.
 */
export interface ModelUsage {
  /** Tokens sent to the model (prompts, context) */
  inputTokens: number;
  /** Tokens generated by the model (responses) */
  outputTokens: number;
  /** Tokens retrieved from cache (reduces cost) */
  cacheReadInputTokens: number;
  /** Tokens stored in cache for future use */
  cacheCreationInputTokens: number;
  /** Number of web search requests made */
  webSearchRequests: number;
  /** Estimated cost in US dollars */
  costUSD: number;
  /** Maximum context window size for this model */
  contextWindow: number;
  /** Maximum output tokens this model can generate */
  maxOutputTokens?: number;
}

/**
 * Information about the longest session by duration.
 * Displayed as a notable stat on the dashboard.
 */
export interface LongestSession {
  /** Unique session identifier */
  sessionId: string;
  /** Duration in milliseconds */
  duration: number;
  /** Number of messages in the session */
  messageCount: number;
  /** When the session started (ISO timestamp) */
  timestamp: string;
}

/**
 * Complete stats cache structure.
 * This is the root object stored in ~/.claude/stats-cache.json
 * and loaded by the /api/stats endpoint.
 */
export interface StatsCache {
  /** Schema version for backwards compatibility */
  version: number;
  /** When these stats were last computed (ISO timestamp) */
  lastComputedDate: string;
  /** Array of daily activity records */
  dailyActivity: DailyActivity[];
  /** Array of daily token usage by model */
  dailyModelTokens: DailyModelTokens[];
  /** Map of model name to aggregate usage stats */
  modelUsage: Record<string, ModelUsage>;
  /** Total number of sessions across all projects */
  totalSessions: number;
  /** Total messages across all sessions */
  totalMessages: number;
  /** Details about the longest session */
  longestSession: LongestSession;
  /** When the first session was created (ISO timestamp) */
  firstSessionDate: string;
  /** Map of hour (0-23) to message count for time-of-day analysis */
  hourCounts: Record<string, number>;
}

// =============================================================================
// SESSION INDEX TYPES
// Source: ~/.claude/projects/{project-id}/sessions-index.json
// Quick-access metadata about sessions without reading full JSONL files
// =============================================================================

/**
 * Summary entry for a session in the project's session index.
 * Used for listing sessions without loading full message history.
 */
export interface SessionIndexEntry {
  /** Unique session identifier (UUID format) */
  sessionId: string;
  /** Absolute path to the session's JSONL file */
  fullPath: string;
  /** File modification time as Unix timestamp (milliseconds) */
  fileMtime: number;
  /** First user message in the session (truncated for preview) */
  firstPrompt: string;
  /** Total number of messages in the session */
  messageCount: number;
  /** When the session was created (ISO timestamp) */
  created: string;
  /** When the session was last modified (ISO timestamp) */
  modified: string;
  /** Git branch active when session started */
  gitBranch: string;
  /** Absolute path to the project directory */
  projectPath: string;
  /** Whether this is a sidechain session (branched conversation) */
  isSidechain: boolean;
}

/**
 * Session index file structure for a project.
 * Contains metadata for all sessions in a project.
 */
export interface SessionIndex {
  /** Schema version for backwards compatibility */
  version: number;
  /** Array of session summary entries */
  entries: SessionIndexEntry[];
}

// =============================================================================
// PROJECT TYPES
// Derived from directory structure at ~/.claude/projects/
// =============================================================================

/**
 * Project information derived from the projects directory.
 * A project corresponds to a working directory where Claude Code was used.
 */
export interface Project {
  /** URL-encoded project path used as directory name */
  id: string;
  /** Human-readable project name (extracted from path) */
  name: string;
  /** Absolute path to the project's session storage directory */
  path: string;
  /** Number of sessions in this project */
  sessionCount: number;
  /** Most recent session activity (ISO timestamp) */
  lastActivity: string;
}

// =============================================================================
// MESSAGE TYPES
// Source: Individual lines in ~/.claude/projects/{project-id}/{session-id}.jsonl
// Each line is a JSON object representing one message
// =============================================================================

/**
 * Content block within a message.
 * Messages can contain multiple content blocks of different types.
 */
export interface MessageContent {
  /** Content type: "text", "tool_use", or "tool_result" */
  type: string;
  /** Text content (for type="text") */
  text?: string;
  /** Reference to the tool call this result belongs to (for type="tool_result") */
  tool_use_id?: string;
  /** Tool name (for type="tool_use", e.g., "Bash", "Read", "Write") */
  name?: string;
  /** Tool input parameters (for type="tool_use") */
  input?: unknown;
  /** Tool execution result (for type="tool_result") */
  content?: string;
}

/**
 * Core message structure with role and content.
 * Content can be a simple string or array of content blocks.
 */
export interface Message {
  /** Who sent the message: "user" or "assistant" */
  role: "user" | "assistant";
  /** Message content - string for simple text, array for complex messages with tools */
  content: string | MessageContent[];
}

/**
 * Complete session message as stored in JSONL files.
 * Each line in a session's JSONL file represents one SessionMessage.
 */
export interface SessionMessage {
  /** Message sender type */
  type: "user" | "assistant" | string;
  /** Unique identifier for this message */
  uuid: string;
  /** UUID of parent message (for conversation threading) */
  parentUuid: string | null;
  /** Session this message belongs to */
  sessionId: string;
  /** When the message was created (ISO timestamp) */
  timestamp: string;
  /** The actual message content */
  message: Message;
  /** Working directory when message was sent */
  cwd?: string;
  /** Git branch when message was sent */
  gitBranch?: string;
  /** Whether this is a system/meta message (not shown to user) */
  isMeta?: boolean;
}

// =============================================================================
// COMMIT TRACKING TYPES
// Source: ~/.claude/projects/{project-id}/.commits.json
// Git commits made during Claude Code sessions (tracked via hooks)
// =============================================================================

/**
 * Git commit made during a Claude Code session.
 * Tracked by the PostToolUse hook when git commit is executed.
 */
export interface SessionCommit {
  /** Full git commit hash (40 characters) */
  commitHash: string;
  /** Branch the commit was made on */
  branch: string;
  /** Git remote URL (for linking to GitHub/GitLab) */
  repoUrl: string;
  /** Working directory where commit was made */
  cwd: string;
  /** When the commit was made (ISO timestamp) */
  timestamp: string;
}

// =============================================================================
// SESSION WITH FULL DATA
// Combines index entry with loaded messages and commits
// =============================================================================

/**
 * Complete session data including messages and commits.
 * This is the full session loaded when viewing a conversation.
 */
export interface Session {
  /** Unique session identifier */
  id: string;
  /** Project this session belongs to */
  projectId: string;
  /** First user message (preview text) */
  firstPrompt: string;
  /** Total number of messages */
  messageCount: number;
  /** When session was created (ISO timestamp) */
  created: string;
  /** When session was last modified (ISO timestamp) */
  modified: string;
  /** Git branch when session started */
  gitBranch: string;
  /** Full message history (loaded on demand) */
  messages?: SessionMessage[];
  /** Git commits made during this session (loaded on demand) */
  commits?: SessionCommit[];
}

// =============================================================================
// API RESPONSE TYPES
// Wrapper types for API endpoint responses
// =============================================================================

/** Response from GET /api/projects */
export interface ProjectsResponse {
  projects: Project[];
}

/** Response from GET /api/projects/[id] */
export interface ProjectDetailResponse {
  project: Project;
  sessions: SessionIndexEntry[];
}

/** Response from GET /api/sessions/[id] */
export interface SessionResponse {
  session: Session;
}

/** Response from GET /api/stats */
export interface StatsResponse {
  stats: StatsCache;
}

// =============================================================================
// KNOWLEDGE/MEMORY TYPES
// Source: .data/ directory generated by CLI
// Extracted and consolidated knowledge from Claude Code sessions
// =============================================================================

/**
 * Episodic memory - specific incidents and their resolutions.
 * Tracks problems encountered and how they were solved.
 */
export interface EpisodicMemory {
  /** Description of the incident or problem */
  incident: string;
  /** How the incident was resolved */
  resolution: string;
  /** Number of times this incident occurred */
  occurrences: number;
  /** Session IDs where this incident occurred */
  sessions: string[];
  /** Last date this incident was seen (YYYY-MM-DD) */
  last_seen: string;
  /** Scope of applicability: "universal" or "project-specific" */
  scope?: string;
}

/**
 * Semantic memory - factual knowledge about the project.
 * Stores information learned about architecture, dependencies, etc.
 */
export interface SemanticMemory {
  /** The knowledge/fact learned */
  knowledge: string;
  /** Category of knowledge: "architecture", "dependencies", "patterns", etc. */
  category: string;
  /** How many times this knowledge was referenced */
  frequency: number;
  /** Confidence level: "high", "medium", or "low" */
  confidence: string;
}

/**
 * Procedural memory - workflows and step-by-step processes.
 * Captures how to perform specific tasks.
 */
export interface ProceduralMemory {
  /** Name/title of the workflow */
  workflow: string;
  /** Ordered list of steps to complete the workflow */
  steps: string[];
  /** Condition that triggers this workflow */
  trigger: string;
  /** Number of times this workflow was used */
  times_used: number;
}

/**
 * Decision record - architectural/design decisions made.
 */
export interface DecisionRecord {
  /** The decision that was made */
  decision: string;
  /** Why this decision was made */
  rationale: string;
  /** Other options that were considered */
  alternatives_considered: string[];
  /** Current status: "active", "superseded", etc. */
  status: string;
  /** Date the decision was made (YYYY-MM-DD) */
  date: string;
}

/**
 * Gotcha - common pitfall or issue to watch out for.
 */
export interface Gotcha {
  /** Description of the issue */
  issue: string;
  /** Root cause if known */
  cause: string | null;
  /** How to fix or work around the issue */
  solution: string;
  /** Tags for categorization */
  tags: string[];
  /** How many times this gotcha was encountered */
  frequency: number;
  /** Scope of applicability: "universal" or "project-specific" */
  scope?: string;
}

/**
 * Consolidated knowledge for a project.
 * Contains all extracted knowledge types.
 */
export interface ProjectKnowledge {
  /** Project identifier */
  project: string;
  /** Path to the project (may be null) */
  project_path: string | null;
  /** When the knowledge was generated (ISO timestamp) */
  generated_at: string;
  /** Number of sessions analyzed */
  sessions_analyzed: number;
  /** Last session timestamp (ISO) */
  last_session: string;
  /** Episodic memories (incidents/resolutions) */
  episodic: EpisodicMemory[];
  /** Semantic memories (facts/knowledge) */
  semantic: SemanticMemory[];
  /** Procedural memories (workflows) */
  procedural: ProceduralMemory[];
  /** Architectural decisions */
  decisions: DecisionRecord[];
  /** Common pitfalls/gotchas */
  gotchas: Gotcha[];
}

/**
 * Session extraction - raw extraction from a single session.
 */
export interface SessionExtraction {
  /** Session UUID */
  session_id: string;
  /** Project name */
  project: string;
  /** When extraction was performed (ISO timestamp) */
  extracted_at: string;
  /** Brief summary of the session */
  session_summary: string;
  /** Episodic memories from this session */
  episodic: Array<{
    incident: string;
    context: string;
    resolution: string;
    file: string | null;
    severity: string;
  }>;
  /** Semantic knowledge from this session */
  semantic: Array<{
    knowledge: string;
    category: string;
    confidence: string;
  }>;
  /** Procedural workflows from this session */
  procedural: Array<{
    workflow: string;
    steps: string[];
    trigger: string;
  }>;
  /** Decisions made in this session */
  decisions: Array<{
    decision: string;
    rationale: string;
    alternatives_considered: string[];
    date: string | null;
  }>;
  /** Gotchas discovered in this session */
  gotchas: Array<{
    issue: string;
    cause: string | null;
    solution: string;
    tags: string[];
  }>;
}

/**
 * Task - a generated task/issue from analysis.
 */
export interface Task {
  /** Task title */
  title: string;
  /** Detailed description */
  description: string;
  /** Type: "fix", "improvement", "feature", etc. */
  task_type: string;
  /** Priority: "high", "medium", "low" */
  priority: string;
  /** Original issue that triggered this task */
  source_issue: string;
  /** Suggested implementation approach */
  suggested_approach: string;
  /** Tags for categorization */
  tags: string[];
}

/**
 * Verification issue found during validation.
 */
export interface VerificationIssue {
  /** Issue type: "stale", "missing", "incorrect", etc. */
  type: string;
  /** Severity: "info", "warning", "error" */
  severity: string;
  /** Where the issue was found */
  location: string;
  /** Description of the issue */
  description: string;
  /** Whether this was tested */
  tested: boolean;
  /** Result of testing */
  test_result: string;
  /** Suggested fix */
  suggestion: string;
}

/**
 * Verification item - an item that was tested.
 */
export interface VerificationItem {
  /** Item that was tested */
  item: string;
  /** Whether it's still valid */
  still_valid: boolean;
  /** Method used to test */
  test_method: string;
}

/**
 * Verification results from validation.
 */
export interface Verification {
  /** Whether the content is valid overall */
  is_valid: boolean;
  /** Validation score (0-100) */
  score: number;
  /** Issues found during validation */
  issues: VerificationIssue[];
  /** Items that were tested */
  items_tested: VerificationItem[];
  /** Items that are stale */
  stale_items: string[];
  /** Summary of verification */
  summary: string;
}

/**
 * Skill - a generated skill/command.
 */
export interface Skill {
  /** Skill name */
  name: string;
  /** Skill content (markdown) */
  content: string;
}

/**
 * Knowledge data for a project including all sources.
 */
export interface KnowledgeData {
  /** Project identifier */
  project: string;
  /** Consolidated knowledge (from knowledge.json) */
  knowledge: ProjectKnowledge | null;
  /** Generated CLAUDE.md content */
  claudeMd: string | null;
  /** Raw session extractions */
  extractions: SessionExtraction[];
  /** Generated tasks */
  tasks: Task[];
  /** Verification results */
  verification: Verification | null;
  /** Full memory data (from memory/consolidated.json) */
  memory: ProjectKnowledge | null;
  /** Generated skills */
  skills: Skill[];
}

/** Response from GET /api/knowledge */
export interface KnowledgeResponse {
  projects: Array<{
    id: string;
    name: string;
  }>;
}

/** Response from GET /api/knowledge/[project] */
export interface ProjectKnowledgeResponse {
  data: KnowledgeData;
}
